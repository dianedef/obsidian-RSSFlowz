import { Plugin, requestUrl } from 'obsidian'
import { createRSSError, RSSErrorCode } from '../types/errors'
import { LogService } from './LogService'
import { Feed, RSSFeed, RSSItem } from '../types'
import { XMLParser } from 'fast-xml-parser'

/**
 * Handles fetching and parsing RSS/Atom feeds
 * 
 * Key responsibilities:
 * - Fetch feeds with appropriate headers to maximize compatibility
 * - Parse both RSS 2.0 and Atom feed formats
 * - Clean and normalize XML to handle malformed feeds
 * - Extract articles with all metadata (title, content, author, etc.)
 * 
 * Uses fast-xml-parser for efficient XML parsing with configurable options
 */
export class RSSService {
  private parser: XMLParser

  constructor(
    private plugin: Plugin,
    private logService: LogService
  ) {
    // Configure XML parser for maximum compatibility with diverse feed formats
    this.parser = new XMLParser({
      ignoreAttributes: false,        // Keep attributes like <link href="...">
      attributeNamePrefix: '@_',      // Prefix to distinguish attributes from text
      removeNSPrefix: true,           // Strip XML namespaces (dc:creator → creator)
      textNodeName: '_text',          // Property name for text content
      parseAttributeValue: true,      // Convert "123" to 123 where appropriate
      trimValues: true                // Remove leading/trailing whitespace
    })
  }

  /**
   * Sanitize XML to fix common feed issues
   * 
   * Problems this solves:
   * - Leading whitespace before <?xml declaration breaks parsers
   * - BOM (Byte Order Mark) \uFEFF confuses parsers
   * - Control characters cause parsing errors
   * 
   * Why needed: Many RSS feeds are generated by broken software
   */
  private cleanXML(xml: string): string {
    return xml
      .replace(/^\s+/, '')        // Remove leading whitespace
      .replace(/^\uFEFF/, '')     // Remove UTF-8 BOM
      .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')  // Remove control chars
  }

  /**
   * Fetch and parse an RSS/Atom feed
   * 
   * HTTP headers are carefully chosen for maximum compatibility:
   * - User-Agent identifies the client (some servers block generic agents)
   * - Accept specifies RSS/Atom MIME types (helps with content negotiation)
   * - Accept-Language requests localized content
   * - Cache-Control ensures fresh content on manual refresh
   * 
   * @param url - Feed URL to fetch
   * @param feed - Feed configuration (used for maxArticles, etc.)
   * @returns Parsed feed with articles
   */
  async fetchFeed(url: string, feed: Feed): Promise<RSSFeed> {
    try {
      this.logService.debug({
        message: 'Récupération du flux RSS',
        data: { url }
      })
      
      const response = await request({
        url,
        headers: {
          'User-Agent': 'Obsidian RSS Reader',
          'Accept': 'application/rss+xml, application/atom+xml, application/xml, text/xml',
          'Accept-Language': 'fr,fr-FR;q=0.9,en;q=0.8',
          'Cache-Control': 'no-cache'
        }
      })

      if (!response) {
        throw createRSSError(
          RSSErrorCode.FETCH_ERROR,
          'Pas de réponse du serveur',
          url
        )
      }

      try {
        const cleanedXML = this.cleanXML(response)
        const parsed = this.parser.parse(cleanedXML)

        if (parsed.parsererror) {
          throw createRSSError(
            RSSErrorCode.PARSE_ERROR,
            `Erreur de parsing XML: ${parsed.parsererror._text || 'Format XML invalide'}`,
            url
          )
        }

        return this.parseFeedData(parsed, url, feed)
      } catch (parseError) {
        throw createRSSError(
          RSSErrorCode.PARSE_ERROR,
          'Erreur lors du parsing du flux XML',
          url
        )
      }
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      this.logService.error({
        message: 'Erreur lors de la récupération du flux RSS',
        error,
        data: { url }
      })
      throw error
    }
  }

  /**
   * Detect feed format and delegate to appropriate parser
   * 
   * RSS 2.0 structure: <rss><channel><item>...</item></channel></rss>
   * Atom structure: <feed><entry>...</entry></feed>
   * 
   * This abstraction allows uniform handling of both formats
   */
  private parseFeedData(data: Record<string, any>, url: string, feed: Feed): RSSFeed {
    if (data.rss?.channel) {
      return this.parseRSSFeed(data.rss.channel, feed, url)
    } else if (data.feed) {
      return this.parseAtomFeed(data.feed, feed, url)
    }

    throw createRSSError(
      RSSErrorCode.PARSE_ERROR,
      'Format de flux non supporté',
      url
    )
  }

  private parseRSSFeed(channel: Record<string, any>, feed: Feed, feedUrl: string): RSSFeed {
    const rssFeed: RSSFeed = {
      title: channel.title?._text || feed.settings.title || '',
      description: channel.description?._text || '',
      link: channel.link?._text || '',
      items: [],
      feedUrl,
      lastUpdate: new Date()
    }

    if (channel.item) {
      const items = Array.isArray(channel.item) ? channel.item : [channel.item]
      rssFeed.items = items
        .slice(0, feed.settings.maxArticles || 50)
        .map((item: Record<string, any>) => this.parseRSSItem(item, feed))
    }

    return rssFeed
  }

  /**
   * Parse a single RSS 2.0 item into normalized format
   * 
   * Content extraction strategy (in priority order):
   * 1. content:encoded - Full HTML content (WordPress, Medium)
   * 2. encoded - Alternative encoding field
   * 3. description - Summary or full content (varies by feed)
   * 
   * Why multiple fields: RSS spec doesn't standardize full content,
   * so publishers use various extensions (content:encoded, dc:creator, etc.)
   */
  private parseRSSItem(item: Record<string, any>, feed: Feed): RSSItem {
    const content = 
      item['content:encoded']?._text?.trim() ||  // WordPress-style full content
      item.encoded?._text?.trim() ||              // Alternative encoding
      item.description?._text?.trim() ||          // Fallback to description
      ''

    return {
      title: item.title?._text?.trim() || 'Sans titre',
      description: item.description?._text?.trim() || '',
      content: content,
      link: item.link?._text?.trim() || '',
      pubDate: item.pubDate?._text ? new Date(item.pubDate._text) : new Date(),
      guid: item.guid?._text || item.link?._text || '',  // GUID fallback to link
      categories: feed.settings.tags || [],
      author: item.author?._text || item.creator?._text || '',  // creator for Dublin Core
      feedTitle: feed.settings.title
    }
  }

  private parseAtomFeed(atomData: Record<string, any>, feed: Feed, feedUrl: string): RSSFeed {
    const atomFeed: RSSFeed = {
      title: atomData.title?._text || feed.settings.title || '',
      description: atomData.subtitle?._text || '',
      link: this.getAtomLink(atomData.link) || '',
      items: [],
      feedUrl,
      lastUpdate: new Date()
    }

    if (atomData.entry) {
      const entries = Array.isArray(atomData.entry) ? atomData.entry : [atomData.entry]
      atomFeed.items = entries
        .slice(0, feed.settings.maxArticles || 50)
        .map((entry: Record<string, any>) => this.parseAtomEntry(entry, feed))
    }

    return atomFeed
  }

  private parseAtomEntry(entry: Record<string, any>, feed: Feed): RSSItem {
    const content = 
      entry.content?._text?.trim() || 
      entry.summary?._text?.trim() || 
      ''
    
    return {
      title: entry.title?._text?.trim() || 'Sans titre',
      description: entry.summary?._text?.trim() || content,
      content: content,
      link: this.getAtomLink(entry.link) || '',
      pubDate: entry.updated?._text ? new Date(entry.updated._text) : 
               entry.published?._text ? new Date(entry.published._text) : new Date(),
      guid: entry.id?._text || this.getAtomLink(entry.link),
      categories: feed.settings.tags || [],
      author: entry.author?.name?._text || '',
      feedTitle: feed.settings.title
    }
  }

  /**
   * Extract URL from Atom link element
   * 
   * Atom links are complex: <link href="..." rel="alternate"/>
   * Can be:
   * - String: "https://example.com" (simple case)
   * - Object: {href: "...", rel: "alternate"}
   * - Array: [{href: "...", rel: "alternate"}, {href: "...", rel: "self"}]
   * 
   * Strategy: Prefer 'alternate' rel (article URL), fall back to first link
   * This handles feeds with multiple links (self, alternate, replies, etc.)
   */
  private getAtomLink(link: Record<string, any> | Record<string, any>[] | string | undefined): string {
    if (!link) {
      return ''
    }

    if (typeof link === 'string') {
      return link
    }

    if (Array.isArray(link)) {
      // Find 'alternate' link (article URL) or use first link
      const alternate = link.find(l => l['@_rel'] === 'alternate' || !l['@_rel'])
      return alternate ? alternate['@_href'] : link[0]['@_href']
    }

    return link['@_href'] || ''
  }

  async cleanup(): Promise<void> {
    try {
      // Annuler toutes les requêtes en cours si nécessaire
      // Nettoyer le cache si existant
      this.logService.debug('RSSService nettoyé avec succès');
    } catch (error) {
      this.logService.error('Erreur lors du nettoyage du RSSService', { error: error as Error });
      throw error;
    }
  }
} 